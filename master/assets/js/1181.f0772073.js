(window.webpackJsonp=window.webpackJsonp||[]).push([[1181],{2525:function(t,a,e){"use strict";e.r(a);var s=e(18),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"模块参考-驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块参考-驱动"}},[t._v("#")]),t._v(" 模块参考：驱动")]),t._v(" "),e("p",[t._v("子分类")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/zh/modules/modules_driver_imu.html"}},[t._v("Imu")])],1),t._v(" "),e("li",[t._v("[Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/distance_sensor/pga460",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/distance_sensor/pga460"),e("OutboundLink")],1),t._v("](modules_driver_distance_sensor.md)")]),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/zh/modules/modules_driver_airspeed_sensor.html"}},[t._v("Airspeed Sensor")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/zh/modules/modules_driver_baro.html"}},[t._v("Baro")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/zh/modules/modules_driver_optical_flow.html"}},[t._v("光流")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/zh/modules/modules_driver_magnetometer.html"}},[t._v("磁力计")])],1)]),t._v(" "),e("h2",{attrs:{id:"adc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#adc"}},[t._v("#")]),t._v(" adc")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/adc/board_adc",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/adc/board_adc"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("To write to flash to set parameters. address, number_of_bytes, byte0, ... , byteN")]),t._v(" "),e("p",[e("a",{attrs:{id:"adc_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("adc <command> [arguments...]\n Commands:\n   start\n\n   test\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"fmu"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmu"}},[t._v("#")]),t._v(" fmu")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/px4fmu",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/px4fmu"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"ads1115_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-2"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ads1115 <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 72\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"atxxxx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#atxxxx"}},[t._v("#")]),t._v(" atxxxx")]),t._v(" "),e("p",[t._v("This module is responsible for driving the output and reading the input pins. For boards without a separate IO chip (eg. Pixracer), it uses the main channels. On boards with an IO chip (eg. Pixhawk), it uses the AUX channels, and the px4io driver is used for main ones.")]),t._v(" "),e("h3",{attrs:{id:"描述-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-2"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("例如，安装在OmnibusF4SD板子上的用于OSD驱动的ATXXXX芯片")]),t._v(" "),e("p",[t._v("The module is configured via mode_* commands. This defines which of the first N pins the driver should occupy. By using mode_pwm4 for example, pins 5 and 6 can be used by the camera trigger driver or by a PWM rangefinder driver. Alternatively, the fmu can be started in one of the capture modes, and then drivers can register a capture callback with ioctl calls.")]),t._v(" "),e("p",[e("a",{attrs:{id:"atxxxx_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-3"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("atxxxx <command> [arguments...]\n Commands:\n   start\n     [-s]        Internal SPI bus(es)\n     [-S]        External SPI bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-c <val>]  chip-select index (for external SPI)\n                 default: 1\n     [-m <val>]  SPI mode\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"batt-smbus"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#batt-smbus"}},[t._v("#")]),t._v(" batt_smbus")]),t._v(" "),e("p",[t._v("源码位置: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/batt_smbus",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/batt_smbus"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-3"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("用于智能电池的BQ40Z50电量统计芯片")]),t._v(" "),e("h3",{attrs:{id:"示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("通过写入flash来设置它的参数。 address, number_of_bytes, byte0, ... , byteN")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("batt_smbus -X write_flash 19069 2 27 0\n")])])]),e("p",[e("a",{attrs:{id:"batt_smbus_usage"}})]),t._v(" "),e("h3",{attrs:{id:"描述-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-4"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("batt_smbus <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 11\n\n   man_info      Prints manufacturer info.\n\n   unseal        解锁设备的flash来使能 write_flash 命令\n\n   seal          锁住设备的flash来失能 write_flash 命令.\n\n   suspend       从调度循环中挂起该设备\n\n   resume        将该设备从挂起状态恢复\n\n   write_flash   写入flash。 必须先通过unseal 命令来解锁flash。\n     [address]   写入的起始地址\n     [number of bytes] 需要写入的字节数\n     [data[0]...data[n]] 具体的字节数据，使用空格隔开\n\n   stop          停止设备\n\n   status        打印状态信息\n")])])]),e("h2",{attrs:{id:"blinkm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#blinkm"}},[t._v("#")]),t._v(" blinkm")]),t._v(" "),e("p",[t._v("Capture input (rising and falling edges) and print on the console: start the fmu in one of the capture modes:")]),t._v(" "),e("p",[e("a",{attrs:{id:"blinkm_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-4"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("blinkm <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 9\n\n   systemstate\n\n   ledoff\n\n   list\n\n   script\n     -n <val>    Script file name\n                 values: <file>\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"bst"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bst"}},[t._v("#")]),t._v(" bst")]),t._v(" "),e("p",[t._v("This will enable capturing on the 4th pin. Then do:")]),t._v(" "),e("p",[e("a",{attrs:{id:"bst_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-5"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("bst <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 118\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"sf1xx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sf1xx"}},[t._v("#")]),t._v(" sf1xx")]),t._v(" "),e("p",[t._v("Use the "),e("code",[t._v("pwm")]),t._v(" command for further configurations (PWM rate, levels, ...), and the "),e("code",[t._v("mixer")]),t._v(" command to load mixer files.")]),t._v(" "),e("h3",{attrs:{id:"描述-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-5"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("这是DShot输出的驱动。 它跟fmu的驱动很相似，可以简单地替换掉，来实现使用DShot与调速器通讯而不是PWM。")]),t._v(" "),e("p",[t._v("GPS driver module that handles the communication with the device and publishes the position via uORB. It supports multiple protocols (device vendors) and by default automatically selects the correct one.")]),t._v(" "),e("ul",[e("li",[t._v("DShot150, DShot300, DShot600, DShot1200")]),t._v(" "),e("li",[t._v("通过独立的串口遥控，并且发布esc_status消息")]),t._v(" "),e("li",[t._v("通过命令行接口发送 DShot 命令")])]),t._v(" "),e("h3",{attrs:{id:"示例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("The module supports a secondary GPS device, specified via "),e("code",[t._v("-e")]),t._v(" parameter. The position will be published on the second uORB topic instance, but it's currently not used by the rest of the system (however the data will be logged, so that it can be used for comparisons).")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("gps <command> [arguments...]\n Commands:\n   start\n     [-d <val>]  GPS device\n                 values: <file:dev>, default: /dev/ttyS3\n     [-b <val>]  Baudrate (can also be p:<param_name>)\n                 default: 0\n     [-e <val>]  Optional secondary GPS device\n                 values: <file:dev>\n     [-g <val>]  Baudrate (secondary GPS, can also be p:<param_name>)\n                 default: 0\n     [-f]        Fake a GPS signal (useful for testing)\n     [-s]        Enable publication of satellite info\n     [-i <val>]  GPS interface\n                 values: spi|uart, default: uart\n     [-p <val>]  GPS Protocol (default=auto select)\n                 values: ubx|mtk|ash\n\n   stop\n\n   status        print status info\n")])])]),e("p",[t._v("保存之后，设置的反向之后的转向将被认为是正常时候的转向， 所以如果需要再次反转方向只需要再次重复相同的命令。")]),t._v(" "),e("p",[e("a",{attrs:{id:"dshot_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-6"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("dshot <command> [arguments...]\n Commands:\n   start         Start the task (without any mode set, use any of the mode_*\n                 cmds)\n\n All of the mode_* commands will start the module if not running already\n\n   mode_gpio\n\n   mode_pwm      Select all available pins as PWM\n\n   mode_pwm8\n\n   mode_pwm6\n\n   mode_pwm5\n\n   mode_pwm5cap1\n\n   mode_pwm4\n\n   mode_pwm4cap1\n\n   mode_pwm4cap2\n\n   mode_pwm3\n\n   mode_pwm3cap1\n\n   mode_pwm2\n\n   mode_pwm2cap2\n\n   mode_pwm1\n\n   telemetry     Enable Telemetry on a UART\n     <device>    UART device\n\n   reverse       Reverse motor direction\n     [-m <val>]  Motor index (1-based, default=all)\n\n   normal        Normal motor direction\n     [-m <val>]  Motor index (1-based, default=all)\n\n   save          Save current settings\n     [-m <val>]  Motor index (1-based, default=all)\n\n   3d_on         Enable 3D mode\n     [-m <val>]  Motor index (1-based, default=all)\n\n   3d_off        Disable 3D mode\n     [-m <val>]  Motor index (1-based, default=all)\n\n   beep1         Send Beep pattern 1\n     [-m <val>]  Motor index (1-based, default=all)\n\n   beep2         Send Beep pattern 2\n     [-m <val>]  Motor index (1-based, default=all)\n\n   beep3         Send Beep pattern 3\n     [-m <val>]  Motor index (1-based, default=all)\n\n   beep4         Send Beep pattern 4\n     [-m <val>]  Motor index (1-based, default=all)\n\n   beep5         Send Beep pattern 5\n     [-m <val>]  Motor index (1-based, default=all)\n\n   esc_info      Request ESC information\n     -m <val>    Motor index (1-based)\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"fmu-mode-pwm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmu-mode-pwm"}},[t._v("#")]),t._v(" fmu mode_pwm")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/examples/fake_gyro",target:"_blank",rel:"noopener noreferrer"}},[t._v("examples/fake_gyro"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-6"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[e("a",{attrs:{id:"fake_gyro_usage"}})]),t._v(" "),e("h3",{attrs:{id:"描述-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-7"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("fake_gyro <command> [arguments...]\n mc_att_control <command> [arguments...]\n Commands:\n   start\n\n   stop\n\n   status        打印状态信息\n")])])]),e("h2",{attrs:{id:"fake-magnetometer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fake-magnetometer"}},[t._v("#")]),t._v(" fake_magnetometer")]),t._v(" "),e("p",[t._v("Starting 2 GPS devices (the main GPS on /dev/ttyS3 and the secondary on /dev/ttyS4): gps start -d /dev/ttyS3 -e /dev/ttyS4")]),t._v(" "),e("h3",{attrs:{id:"描述-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-8"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("Publish the earth magnetic field as a fake magnetometer (sensor_mag). Requires vehicle_attitude and vehicle_gps_position.")]),t._v(" "),e("p",[e("a",{attrs:{id:"fake_magnetometer_usage"}})]),t._v(" "),e("h3",{attrs:{id:"描述-9"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-9"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("fake_magnetometer <command> [arguments...]\n mc_att_control <command> [arguments...]\n Commands:\n   start\n\n   stop\n\n   status        打印状态信息\n")])])]),e("h2",{attrs:{id:"gps"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gps"}},[t._v("#")]),t._v(" gps")]),t._v(" "),e("p",[t._v("源码："),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/gps",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/gps"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-10"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-10"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("GPS 驱动模块负责处理与设备的通信并且将位置信息通过 uORB 发布出去。 它支持多个协议 (设备供应商)，默认情况下会自动选择正确的协议。")]),t._v(" "),e("p",[t._v("模块支持一个辅助（secondary） GPS 设备，可使用 "),e("code",[t._v("-e")]),t._v(" 参数进行指定。 辅助 GPS 的位置信息会在第二个 uORB 主题实例上发布，但目前为止系统的其它部分暂未使用该数据（但该数据会被记录下来，以方便进行对比）。")]),t._v(" "),e("h3",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("每个设备都有一个线程轮询数据。 There is a thread for each device polling for data. The GPS protocol classes are implemented with callbacks so that they can be used in other projects as well (eg. QGroundControl uses them too).")]),t._v(" "),e("h3",{attrs:{id:"示例-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-3"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("进行测试时能提供虚假的 GPS 信号是非常有用的（它可以告知系统当前已经获得了一个有效的位置）。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("gps stop\ngps start -f\n")])])]),e("p",[t._v("pga460 <command> [arguments...] Commands: start <device_path> [device_path] The pga460 sensor device path, (e.g: /dev/ttyS6 status stop help")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("sf1xx stop\n")])])]),e("p",[t._v("Initiate warm restart of GPS device")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("sf1xx <command> [arguments...]\n Commands:\n   start         Start driver\n     [-a]        Attempt to start driver on all I2C buses\n     [-b <val>]  Start driver on specific I2C bus\n                 default: 1\n     [-R <val>]  Sensor rotation - downward facing by default\n                 default: 25\n\n   stop          Stop driver\n\n   test          Test driver (basic functional tests)\n\n   reset         Reset driver\n\n   info          Print driver information\n")])])]),e("p",[e("a",{attrs:{id:"gps_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-7"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("gps <command> [arguments...]\n Commands:\n   start\n     [-d <val>]  GPS device\n                 values: <file:dev>, default: /dev/ttyS3\n     [-b <val>]  Baudrate (can also be p:<param_name>)\n                 default: 0\n     [-e <val>]  Optional secondary GPS device\n                 values: <file:dev>\n     [-g <val>]  Baudrate (secondary GPS, can also be p:<param_name>)\n                 default: 0\n     [-f]        Fake a GPS signal (useful for testing)\n     [-s]        Enable publication of satellite info\n     [-i <val>]  GPS interface\n                 values: spi|uart, default: uart\n     [-j <val>]  secondary GPS interface\n                 values: spi|uart, default: uart\n     [-p <val>]  GPS Protocol (default=auto select)\n                 values: ubx|mtk|ash|eml\n\n   stop\n\n   status        print status info\n\n   reset         Reset GPS device\n     cold|warm|hot Specify reset type\n")])])]),e("h2",{attrs:{id:"ina226"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ina226"}},[t._v("#")]),t._v(" ina226")]),t._v(" "),e("p",[t._v("This module does the RC input parsing and auto-selecting the method. Supported methods are:")]),t._v(" "),e("h3",{attrs:{id:"描述-11"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-11"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("By default the module runs on the work queue, to reduce RAM usage. It can also be run in its own thread, specified via start flag -t, to reduce latency. When running on the work queue, it schedules at a fixed frequency.")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/distance_sensor/sf1xx",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/distance_sensor/sf1xx"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("I2C bus driver for Lightware SFxx series LIDAR rangefinders: SF10/a, SF10/b, SF10/c, SF11/c, SF/LW20.")]),t._v(" "),e("p",[t._v("If the INA226 module is not powered, then by default, initialization of the driver will fail. To change this, use the -f flag. If this flag is set, then if initialization fails, the driver will keep trying to initialize again every 0.5 seconds. With this flag set, you can plug in a battery after the driver starts, and it will work. Without this flag set, the battery must be plugged in before starting the driver.")]),t._v(" "),e("p",[e("a",{attrs:{id:"ina226_usage"}})]),t._v(" "),e("h3",{attrs:{id:"描述-12"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-12"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ina226 <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 65\n     [-k]        if initialization (probing) fails, keep retrying periodically\n     [-t <val>]  battery index for calibration values (1 or 2)\n                 default: 1\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"irlock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#irlock"}},[t._v("#")]),t._v(" irlock")]),t._v(" "),e("p",[t._v("Attempt to start driver on any bus (start on bus where first sensor found).")]),t._v(" "),e("p",[e("a",{attrs:{id:"irlock_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-8"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("irlock <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 84\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"fmu-mode-pwm3cap1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fmu-mode-pwm3cap1"}},[t._v("#")]),t._v(" fmu mode_pwm3cap1")]),t._v(" "),e("p",[t._v("Stop driver")]),t._v(" "),e("p",[e("a",{attrs:{id:"lsm303agr_usage"}})]),t._v(" "),e("h3",{attrs:{id:"用法-9"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用法-9"}},[t._v("#")]),t._v(" 用法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("lsm303agr <command> [arguments...]\n Commands:\n   start\n     [-s]        Internal SPI bus(es)\n     [-S]        External SPI bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-c <val>]  chip-select index (for external SPI)\n                 default: 1\n     [-m <val>]  SPI mode\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-R <val>]  Rotation\n                 default: 0\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pga460"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pga460"}},[t._v("#")]),t._v(" pga460")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/optical_flow/paw3902",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/optical_flow/paw3902"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"paw3902_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("paw3902 <command> [arguments...]\n Commands:\n   start\n     [-s]        Internal SPI bus(es)\n     [-S]        External SPI bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-c <val>]  chip-select index (for external SPI)\n                 default: 1\n     [-m <val>]  SPI mode\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-R <val>]  Rotation\n                 default: 0\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pca9685"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pca9685"}},[t._v("#")]),t._v(" pca9685")]),t._v(" "),e("p",[t._v("This module controls the TAP_ESC hardware via UART. It listens on the actuator_controls topics, does the mixing and writes the PWM outputs.")]),t._v(" "),e("p",[e("a",{attrs:{id:"pca9685_usage"}})]),t._v(" "),e("h3",{attrs:{id:"描述-13"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-13"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pca9685 <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n\n   reset\n\n   test          enter test mode\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pca9685-pwm-out"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pca9685-pwm-out"}},[t._v("#")]),t._v(" pca9685_pwm_out")]),t._v(" "),e("p",[t._v("Currently the module is implementd as a threaded version only, meaning that it runs in its own thread instead of on the work queue.")]),t._v(" "),e("h3",{attrs:{id:"描述-14"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-14"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("The module is typically started with: tap_esc start -d /dev/ttyS2 -n")]),t._v(" "),e("p",[t._v("该模块监听 actuator_controls 主题，执行混控并写入 PWM 输出。")]),t._v(" "),e("h3",{attrs:{id:"实现-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-2"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("This module depends on ModuleBase and OutputModuleInterface. IIC communication is based on CDev::I2C")]),t._v(" "),e("h3",{attrs:{id:"示例-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-4"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("通常使用如下命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("sf1xx start -a\n")])])]),e("p",[t._v("Use the "),e("code",[t._v("mixer")]),t._v(" command to load mixer files. "),e("code",[t._v("mixer load /dev/pwm_outputX etc/mixers/quad_x.main.mix")]),t._v(" The number X can be acquired by executing "),e("code",[t._v("pca9685_pwm_out status")]),t._v(" when this driver is running.")]),t._v(" "),e("p",[e("a",{attrs:{id:"pca9685_pwm_out_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-2"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pca9685_pwm_out <command> [arguments...]\n Commands:\n   start         Start the task\n     [-a <val>]  device address on this bus\n                 default: 64\n     [-b <val>]  bus that pca9685 is connected to\n                 default: 1\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pcf8583"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pcf8583"}},[t._v("#")]),t._v(" pcf8583")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/rpm/pcf8583",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/rpm/pcf8583"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"pcf8583_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-3"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pcf8583 <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pmw3901"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pmw3901"}},[t._v("#")]),t._v(" pmw3901")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/optical_flow/pmw3901",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/optical_flow/pmw3901"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"pmw3901_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-4"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pmw3901 <command> [arguments...]\n Commands:\n   start\n     [-s]        Internal SPI bus(es)\n     [-S]        External SPI bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-c <val>]  chip-select index (for external SPI)\n                 default: 1\n     [-m <val>]  SPI mode\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-R <val>]  Rotation\n                 default: 0\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pwm-out"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pwm-out"}},[t._v("#")]),t._v(" pwm_out")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/pwm_out",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/pwm_out"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-15"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-15"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("该模块负责驱动输出引脚或者读取输入引脚。 For boards without a separate IO chip (eg. Pixracer), it uses the main channels. On boards with an IO chip (eg. Pixhawk), it uses the AUX channels, and the px4io driver is used for main ones.")]),t._v(" "),e("p",[t._v("该模块监听 actuator_controls 主题，执行混控并写入 PWM 输出。")]),t._v(" "),e("p",[t._v("该模块使用 mode_* 命令进行配置。 该命令会设定驱动将占用最开始的哪些 N 个针脚。 例如，通过使用 mode_pwm4，引脚 5 和 6 可被分别被相机触发驱动或者 PWM 测距仪驱动使用。 Alternatively, pwm_out can be started in one of the capture modes, and then drivers can register a capture callback with ioctl calls.")]),t._v(" "),e("h3",{attrs:{id:"实现-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-3"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("By default the module runs on the work queue, to reduce RAM usage. It can also be run in its own thread, specified via start flag -t, to reduce latency. When running on the work queue, it schedules at a fixed frequency, and the pwm rate limits the update rate of the actuator_controls topics. In case of running in its own thread, the module polls on the actuator_controls topic. Additionally the pwm rate defines the lower-level IO timer rates.")]),t._v(" "),e("h3",{attrs:{id:"示例-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-5"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("通常使用如下命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pwm_out mode_pwm\n")])])]),e("p",[t._v("来驱动所有可以的引脚。")]),t._v(" "),e("p",[t._v("Capture input (rising and falling edges) and print on the console: start pwm_out in one of the capture modes:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pwm_out mode_pwm3cap1\n")])])]),e("p",[t._v("该命令将启用第 4 引脚上的捕获。 然后执行：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("fmu test\n")])])]),e("p",[t._v("使用 "),e("code",[t._v("pwm")]),t._v(" 命令进行进一步的配置 (PWM 速率，级别, ...)，然后使用 "),e("code",[t._v("mixer")]),t._v(" 命令来加载混控器文件。")]),t._v(" "),e("p",[e("a",{attrs:{id:"pwm_out_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-5"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pwm_out <command> [arguments...]\n fmu <command> [arguments...]\n Commands:\n   start         Start the task (without any mode set, use any of the mode_*\n                 cmds)\n     [-t]        Run as separate task instead of the work queue\n\n All of the mode_* commands will start the fmu if not running already\n\n   mode_gpio\n\n   mode_pwm      Select all available pins as PWM\n\n   mode_pwm8\n\n   mode_pwm6\n\n   mode_pwm5\n\n   mode_pwm5cap1\n\n   mode_pwm4\n\n   mode_pwm4cap1\n\n   mode_pwm3\n\n   mode_pwm3cap1\n\n   mode_pwm2\n\n   mode_pwm2cap2\n\n   mode_pwm1\n\n   sensor_reset  Do a sensor reset (SPI bus)\n     [<ms>]      Delay time in ms between reset and re-enabling\n\n   peripheral_reset Reset board peripherals\n     [<ms>]      Delay time in ms between reset and re-enabling\n\n   i2c           Configure I2C clock rate\n     <bus_id> <rate> Specify the bus id (>=0) and rate in Hz\n\n   test          Test inputs and outputs\n\n   fake          Arm and send an actuator controls command\n     <roll> <pitch> <yaw> <thrust> Control values in range [-100, 100]\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"pwm-out-sim"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pwm-out-sim"}},[t._v("#")]),t._v(" pwm_out_sim")]),t._v(" "),e("p",[t._v("源码："),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/pwm_out_sim",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/pwm_out_sim"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-16"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-16"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("针对仿真模拟的 PWM 输出的驱动。")]),t._v(" "),e("p",[t._v("Its only function is to take "),e("code",[t._v("actuator_control")]),t._v(" uORB messages, mix them with any loaded mixer and output the result to the "),e("code",[t._v("actuator_output")]),t._v(" uORB topic.")]),t._v(" "),e("p",[t._v("该模块在 SITL 和 HITL 仿真中使用。")]),t._v(" "),e("p",[e("a",{attrs:{id:"pwm_out_sim_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-6"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pwm_out_sim <command> [arguments...]\n pwm_out_sim <command> [arguments...]\n Commands:\n   start         Start the task in mode_pwm16\n\n All of the mode_* commands will start the pwm sim if not running already\n\n   mode_pwm      use 8 PWM outputs\n\n   mode_pwm16    use 16 PWM outputs\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"px4flow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#px4flow"}},[t._v("#")]),t._v(" px4flow")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/optical_flow/px4flow",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/optical_flow/px4flow"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"px4flow_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-7"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("px4flow <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 66\n     [-R <val>]  Rotation (default=downwards)\n                 default: 25\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"rc-input"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rc-input"}},[t._v("#")]),t._v(" rc_input")]),t._v(" "),e("p",[t._v("源码："),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/rc_input",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/rc_input"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-17"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-17"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("本模块自动选择合适的方法对 RC 输入进行解析， 受支持的方法有：")]),t._v(" "),e("ul",[e("li",[t._v("PPM")]),t._v(" "),e("li",[t._v("SBUS")]),t._v(" "),e("li",[t._v("DSM")]),t._v(" "),e("li",[t._v("SUMD")]),t._v(" "),e("li",[t._v("ST24")]),t._v(" "),e("li",[t._v("TBS Crossfire (CRSF)")])]),t._v(" "),e("p",[e("a",{attrs:{id:"rc_input_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-8"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("rc_input <command> [arguments...]\n rc_input <command> [arguments...]\n Commands:\n   start         Start the task (without any mode set, use any of the mode_*\n                 cmds)\n     [-t]        Run as separate task instead of the work queue\n\n   bind          Send a DSM bind command (module must be running)\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"rgbled"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rgbled"}},[t._v("#")]),t._v(" rgbled")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/lights/rgbled_ncp5623c",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/lights/rgbled_ncp5623c"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"rgbled_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-9"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-9"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("rgbled <command> [arguments...]\n Commands:\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-a <val>]  I2C address\n                 default: 57\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"roboclaw"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#roboclaw"}},[t._v("#")]),t._v(" roboclaw")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/roboclaw",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/roboclaw"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-18"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-18"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("This driver communicates over UART with the "),e("a",{attrs:{href:"http://downloads.basicmicro.com/docs/roboclaw_user_manual.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Roboclaw motor driver"),e("OutboundLink")],1),t._v(". It performs two tasks:")]),t._v(" "),e("ul",[e("li",[t._v("Control the motors based on the "),e("code",[t._v("actuator_controls_0")]),t._v(" UOrb topic.")]),t._v(" "),e("li",[t._v("Read the wheel encoders and publish the raw data in the "),e("code",[t._v("wheel_encoders")]),t._v(" UOrb topic")])]),t._v(" "),e("p",[t._v("In order to use this driver, the Roboclaw should be put into Packet Serial mode (see the linked documentation), and your flight controller's UART port should be connected to the Roboclaw as shown in the documentation. For Pixhawk 4, use the "),e("code",[t._v("UART & I2C B")]),t._v(" port, which corresponds to "),e("code",[t._v("/dev/ttyS3")]),t._v(".")]),t._v(" "),e("h3",{attrs:{id:"实现-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-4"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("The main loop of this module (Located in "),e("code",[t._v("RoboClaw.cpp::task_main()")]),t._v(") performs 2 tasks:")]),t._v(" "),e("ol",[e("li",[t._v("Write "),e("code",[t._v("actuator_controls_0")]),t._v(" messages to the Roboclaw as they become available")]),t._v(" "),e("li",[t._v("Read encoder data from the Roboclaw at a constant, fixed rate.")])]),t._v(" "),e("p",[t._v("Because of the latency of UART, this driver does not write every single "),e("code",[t._v("actuator_controls_0")]),t._v(" message to the Roboclaw immediately. Instead, it is rate limited based on the parameter "),e("code",[t._v("RBCLW_WRITE_PER")]),t._v(".")]),t._v(" "),e("p",[t._v("On startup, this driver will attempt to read the status of the Roboclaw to verify that it is connected. If this fails, the driver terminates immediately.")]),t._v(" "),e("h3",{attrs:{id:"示例-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-6"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("The command to start this driver is:")]),t._v(" "),e("p",[t._v("$ roboclaw start "),e("device",[e("baud")],1)],1),t._v(" "),e("p",[e("code",[t._v("<device>")]),t._v(" is the name of the UART port. On the Pixhawk 4, this is "),e("code",[t._v("/dev/ttyS3")]),t._v(". "),e("code",[t._v("<baud>")]),t._v(" is te baud rate.")]),t._v(" "),e("p",[t._v("All available commands are:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("$ roboclaw start <device> <baud>")])]),t._v(" "),e("li",[e("code",[t._v("$ roboclaw status")])]),t._v(" "),e("li",[e("code",[t._v("$ roboclaw stop")])])]),t._v(" "),e("p",[e("a",{attrs:{id:"roboclaw_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-10"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-10"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("roboclaw <command> [arguments...]\n Commands:\n")])])]),e("h2",{attrs:{id:"safety-button"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#safety-button"}},[t._v("#")]),t._v(" safety_button")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/safety_button",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/safety_button"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"描述-19"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述-19"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),e("p",[t._v("This module is responsible for the safety button. Pressing the safety button 3 times quickly will trigger a GCS pairing request.")]),t._v(" "),e("p",[e("a",{attrs:{id:"safety_button_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-11"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-11"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("safety_button <command> [arguments...]\n mc_att_control <command> [arguments...]\n Commands:\n   start\n\n   stop\n\n   status        打印状态信息\n")])])]),e("h2",{attrs:{id:"tap-esc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tap-esc"}},[t._v("#")]),t._v(" tap_esc")]),t._v(" "),e("p",[t._v("源码位置: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/tap_esc",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/tap_esc"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"参数描述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数描述"}},[t._v("#")]),t._v(" 参数描述")]),t._v(" "),e("p",[t._v("该模块通过串口来控制TAP_ESC模块。 它负责监听话题actuator_controls，执行混控并输出给调速器设备。")]),t._v(" "),e("h3",{attrs:{id:"实现-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-5"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("目前该模块运行在一个独立的线程中，意思就是它不是在一个工作队列中的模块。")]),t._v(" "),e("h3",{attrs:{id:"示例-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-7"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("这个模块一般使用这个命令来启动: tap_esc start -d /dev/ttyS2 -n <1-8>")]),t._v(" "),e("p",[e("a",{attrs:{id:"tap_esc_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-12"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-12"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("tap_esc <command> [arguments...]\n tap_esc <command> [arguments...]\n Commands:\n   start         Start the task\n     [-d <val>]  Device used to talk to ESCs\n                 values: <device>\n     [-n <val>]  Number of ESCs\n                 default: 4\n")])])]),e("h2",{attrs:{id:"tone-alarm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tone-alarm"}},[t._v("#")]),t._v(" tone_alarm")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/tone_alarm",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/tone_alarm"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"参数描述-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数描述-2"}},[t._v("#")]),t._v(" 参数描述")]),t._v(" "),e("p",[t._v("This module is responsible for the tone alarm.")]),t._v(" "),e("p",[e("a",{attrs:{id:"tone_alarm_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-13"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-13"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("tone_alarm <command> [arguments...]\n wind_estimator &lt;command&gt; [arguments...]\n Commands:\n   start\n\n   stop\n\n   status        打印状态信息\n")])])]),e("h2",{attrs:{id:"vmount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vmount"}},[t._v("#")]),t._v(" vmount")]),t._v(" "),e("p",[t._v("源码位置: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/modules/vmount",target:"_blank",rel:"noopener noreferrer"}},[t._v("modules/vmount"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"参数描述-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数描述-3"}},[t._v("#")]),t._v(" 参数描述")]),t._v(" "),e("p",[t._v("载荷（云台）控制驱动， Mount (Gimbal) control driver. It maps several different input methods (eg. RC or MAVLink) to a configured output (eg. AUX channels or MAVLink).")]),t._v(" "),e("p",[t._v("Documentation how to use it is on the "),e("a",{attrs:{href:"https://dev.px4.io/en/advanced/gimbal_control.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("gimbal_control"),e("OutboundLink")],1),t._v(" page.")]),t._v(" "),e("h3",{attrs:{id:"实现-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-6"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("Each method is implemented in its own class, and there is a common base class for inputs and outputs. They are connected via an API, defined by the "),e("code",[t._v("ControlData")]),t._v(" data structure. This makes sure that each input method can be used with each output method and new inputs/outputs can be added with minimal effort. 各个类通过一个由 "),e("code",[t._v("ControlData")]),t._v(" 数据结构定义的 API 实现相互的连接。 此举确保了每一种输入方法都可以在每一个输出方法中使用，且只需要很少的工作量就可以添加一个新的输入/输出。")]),t._v(" "),e("h3",{attrs:{id:"示例-8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-8"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("通过设定一个固定的偏航角来测试输出功能（其它轴的角度设为0）：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vmount stop\nvmount test yaw 30\n")])])]),e("p",[e("a",{attrs:{id:"vmount_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-14"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-14"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("vmount <command> [arguments...]\n vmount <command> [arguments...]\n Commands:\n   start\n\n   test          Test the output: set a fixed angle for one axis (vmount must\n                 not be running)\n     roll|pitch|yaw <angle> Specify an axis and an angle in degrees\n\n   stop\n\n   status        print status info\n")])])]),e("h2",{attrs:{id:"voxlpm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#voxlpm"}},[t._v("#")]),t._v(" voxlpm")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://github.com/PX4/Firmware/tree/master/src/drivers/power_monitor/voxlpm",target:"_blank",rel:"noopener noreferrer"}},[t._v("drivers/power_monitor/voxlpm"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{id:"voxlpm_usage"}})]),t._v(" "),e("h3",{attrs:{id:"使用-15"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-15"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("voxlpm [arguments...]\n   start\n     [-I]        Internal I2C bus(es)\n     [-X]        External I2C bus(es)\n     [-b <val>]  board-specific bus (default=all) (external SPI: n-th bus\n                 (default=1))\n     [-f <val>]  bus frequency in kHz\n     [-q]        quiet startup (no message if no device found)\n     [-T <val>]  Type\n                 values: VBATT|P5VDC|P12VDC, default: VBATT\n     [-k]        if initialization (probing) fails, keep retrying periodically\n\n   stop\n\n   status        print status info\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);